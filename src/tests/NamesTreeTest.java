package tests;

import baby_names.BabyNames;
import bst.INamesTree;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;

import java.util.ConcurrentModificationException;
import java.util.Iterator;

/**
 * Verifies the behavior of an INamesTree structure.
 *
 * DO NOT EDIT THIS FILE!
 *
 * @author Josh Archer
 * @version 1.0
 */
public class NamesTreeTest
{
    private static final int TEST_YEAR = 2019;
    private static final int TEST_FREQUENCY = 11;

    private INamesTree namesTree;
    private BabyNames[] testElements = {
        new BabyNames("WA", "M", TEST_YEAR, "Barry", TEST_FREQUENCY),
        new BabyNames("WA", "F", TEST_YEAR, "Susie", TEST_FREQUENCY),
        new BabyNames("WA", "M", TEST_YEAR, "Luke", TEST_FREQUENCY),
        new BabyNames("WA", "F", TEST_YEAR, "Twila", TEST_FREQUENCY),
        new BabyNames("WA", "M", TEST_YEAR, "William", TEST_FREQUENCY),
        new BabyNames("WA", "F", TEST_YEAR, "Minnie", TEST_FREQUENCY)
    };
    private String[] names = {"Barry", "Luke", "Minnie", "Susie", "Twila", "William"};

    /**
     * Creates a new tree for each test.
     */
    @Before
    public void setup()
    {
        //instantiate a new structure that implements the INamesTree interface
        namesTree = null;
    }

    private void addTestableElements()
    {
        for (BabyNames names : testElements)
        {
            namesTree.add(names);
        }
    }

    /**
     * Tests whether the structure can report the size of an empty tree.
     */
    @Test
    public void emptyTreeTest()
    {
        //an empty tree should report that it is empty
        Assert.assertEquals("An empty tree has a non-zero size", 0, namesTree.size());
        Assert.assertTrue("An empty tree is reported as being not empty", namesTree.isEmpty());
    }

    /**
     * Tests whether the structure tracks the size of the tree after insertions.
     */
    @Test
    public void addTest()
    {
        //add a few elements
        addTestableElements();

        //test the size reported
        Assert.assertEquals("The number of elements in the tree are not properly tracked", 6, namesTree.size());
        Assert.assertFalse("An occupied tree is reported as empty", namesTree.isEmpty());
    }

    /**
     * Tests whether multiple insertions can be made through the add() method.
     */
    @Test
    public void addMultipleTest()
    {
        //call the add() method with variable length params
        namesTree.add(
            new BabyNames("WA", "M", TEST_YEAR, "Barry", TEST_FREQUENCY),
            new BabyNames("WA", "F", TEST_YEAR, "Susie", TEST_FREQUENCY),
            new BabyNames("WA", "M", TEST_YEAR, "Luke", TEST_FREQUENCY),
            new BabyNames("WA", "F", TEST_YEAR, "Twila", TEST_FREQUENCY),
            new BabyNames("WA", "M", TEST_YEAR, "William", TEST_FREQUENCY),
            new BabyNames("WA", "F", TEST_YEAR, "Minnie", TEST_FREQUENCY)
        );

        Assert.assertEquals("The number of elements in the tree are not properly tracked after " +
                            "calling add() with variable length parameters", 6, namesTree.size());
        Assert.assertFalse("An occupied tree is reported as empty after " +
                            "calling add() with variable length parameters", namesTree.isEmpty());
    }

    /**
     * Tests whether duplicates are rejected by the tree.
     */
    @Test
    public void addDuplicateTest()
    {
        addTestableElements();

        //test size before
        Assert.assertEquals("The number of elements in the tree are not properly tracked", 6, namesTree.size());

        //add duplicates
        namesTree.add(new BabyNames("WA", "M", TEST_YEAR, "Barry", TEST_FREQUENCY));
        namesTree.add(new BabyNames("WA", "F", TEST_YEAR, "Susie", TEST_FREQUENCY));
        namesTree.add(new BabyNames("WA", "M", TEST_YEAR, "Luke", TEST_FREQUENCY));

        //test size after
        Assert.assertEquals("The number of elements in the tree are not properly tracked", 6, namesTree.size());
    }

    /**
     * Tests whether contains() can identify elements in the tree.
     */
    @Test
    public void containsExistsTest()
    {
        addTestableElements();

        //make sure we can find all elements
        for (BabyNames names : testElements)
        {
            Assert.assertTrue("Element inserted into tree cannot be found with contains()",
                    namesTree.contains(names));
        }
    }

    /**
     * Tests whether missing elements are identified correctly by contains().
     */
    @Test
    public void containsMissingTest()
    {
        addTestableElements();

        //names not in tree
        BabyNames[] notInTree = {
            new BabyNames("OR", "F", TEST_YEAR, "Liu", TEST_FREQUENCY),
            new BabyNames("WA", "M", TEST_YEAR, "Todd", TEST_FREQUENCY),
            new BabyNames("WA", "F", TEST_YEAR, "Mindy", TEST_FREQUENCY),
        };

        //make sure we cannot find any of these elements elements
        for (BabyNames names : notInTree)
        {
            Assert.assertFalse("Element not into tree can be found with contains()",
                    namesTree.contains(names));
        }
    }

    /**
     * Tests whether get() can find elements in the tree.
     */
    @Test
    public void getExistsTest()
    {
        addTestableElements();

        //make sure we can find all elements
        for (BabyNames names : testElements)
        {
            Assert.assertEquals("Element inserted into tree cannot be found with contains()",
                    names, namesTree.get(names.getName()));
        }
    }

    /**
     * Tests whether get() will not find missing elements.
     */
    @Test
    public void getMissingTest()
    {
        //names not in tree
        BabyNames[] notInTree = {
            new BabyNames("OR", "F", TEST_YEAR, "Liu", TEST_FREQUENCY),
            new BabyNames("WA", "M", TEST_YEAR, "Todd", TEST_FREQUENCY),
            new BabyNames("WA", "F", TEST_YEAR, "Mindy", TEST_FREQUENCY),
        };

        //make sure we cannot find any of these elements elements
        for (BabyNames names : notInTree)
        {
            Assert.assertNull("Element not into tree can be found with get()",
                    namesTree.get(names.getName()));
        }
    }

    /**
     * Tests whether the structure is consistent before and after a call to clear.
     */
    @Test
    public void clearTest()
    {
        //before clear()
        addTestableElements();
        Assert.assertEquals("The number of elements in the tree are not properly tracked", 6, namesTree.size());
        Assert.assertFalse("An occupied tree is reported as empty", namesTree.isEmpty());

        //after clear()
        namesTree.clear();
        Assert.assertEquals("The number of elements in the tree are not properly tracked", 0, namesTree.size());
        Assert.assertTrue("An unoccupied tree is reported as not empty", namesTree.isEmpty());
    }

    /**
     * Tests whether the clear() method behaves properly when called on an empty tree.
     */
    @Test
    public void emptyTreeClearTest()
    {
        namesTree.clear();
        Assert.assertEquals("The number of elements in the tree are not properly tracked", 0, namesTree.size());
        Assert.assertTrue("An unoccupied tree is reported as not empty", namesTree.isEmpty());
    }

    /**
     * Tests whether the tree height can be calculated after multiple insertions.
     */
    @Test
    public void treeHeightTest()
    {
        addTestableElements();
        Assert.assertEquals("Tree height is incorrect after calling insert", 3, namesTree.treeHeight());
    }

    /**
     * Tests whether an empty tree reports the correct tree height.
     */
    @Test
    public void emptyTreeHeightTest()
    {
        Assert.assertEquals("Tree height is incorrect on an empty tree", -1, namesTree.treeHeight());
    }

    /**
     * Tests whether each Node height has been calculated correctly.
     */
    @Test
    public void nodeHeightTest()
    {
        addTestableElements();

        //verify the height of all six elements
        Assert.assertEquals("Node height is incorrect", 3, namesTree.nodeHeight(testElements[0])); //Barry
        Assert.assertEquals("Node height is incorrect", 2, namesTree.nodeHeight(testElements[1])); //Susie
        Assert.assertEquals("Node height is incorrect", 1, namesTree.nodeHeight(testElements[2])); //Luke
        Assert.assertEquals("Node height is incorrect", 1, namesTree.nodeHeight(testElements[3])); //Twila
        Assert.assertEquals("Node height is incorrect", 0, namesTree.nodeHeight(testElements[4])); //William
        Assert.assertEquals("Node height is incorrect", 0, namesTree.nodeHeight(testElements[5])); //Minnie
    }

    /**
     * Tests whether each Node height has been calculated correctly for an empty list.
     */
    @Test
    public void nodeHeightEmptyTreeTest()
    {
        for (BabyNames names : testElements)
        {
            Assert.assertEquals("Node height is incorrect", -1, namesTree.nodeHeight(names));
        }
    }

    /**
     * Tests whether each Node height has been calculated correctly.
     */
    @Test
    public void nodeDepthTest()
    {
        addTestableElements();

        //verify the height of all six elements
        Assert.assertEquals("Node depth is incorrect", 0, namesTree.nodeDepth(testElements[0])); //Barry
        Assert.assertEquals("Node depth is incorrect", 1, namesTree.nodeDepth(testElements[1])); //Susie
        Assert.assertEquals("Node depth is incorrect", 2, namesTree.nodeDepth(testElements[2])); //Luke
        Assert.assertEquals("Node depth is incorrect", 2, namesTree.nodeDepth(testElements[3])); //Twila
        Assert.assertEquals("Node depth is incorrect", 3, namesTree.nodeDepth(testElements[4])); //William
        Assert.assertEquals("Node depth is incorrect", 3, namesTree.nodeDepth(testElements[5])); //Minnie
    }

    /**
     * Tests whether each Node height has been calculated correctly for an empty list.
     */
    @Test
    public void nodeDepthEmptyTreeTest()
    {
        for (BabyNames names : testElements)
        {
            Assert.assertEquals("Node depth is incorrect", -1, namesTree.nodeDepth(names));
        }
    }

    /**
     * Verifies that an iterator will not return elements on an empty tree
     */
    @Test
    public void iteratorWithEmptyStackTest()
    {
        Iterator<BabyNames> iter = namesTree.iterator();
        Assert.assertFalse("Iterator should not report elements for an empty list",
                iter.hasNext());
    }

    /**
     * Verifies that an iterator can identify elements to be returned and return them
     * using the in-order traversal.
     */
    @Test
    public void iteratorTest()
    {
        addTestableElements();

        //verify elements returned in-order
        Iterator<BabyNames> iter = namesTree.iterator();
        for (int i = 0; i < names.length; i++)
        {
            Assert.assertTrue("hasNext() should return true for existing elements in the list",
                    iter.hasNext());
            Assert.assertEquals("next() should return elements in order",
                    names[i], iter.next().getName());
        }

        Assert.assertFalse("Iterator should not report elements for an empty list",
                iter.hasNext());
    }

    /**
     * Verifies that a for-each loop can be used with the tree.
     */
    @Test
    public void forEachTest()
    {
        addTestableElements();

        //a for-each loop should run without error
        int count = 0;
        for (BabyNames element : namesTree)
        {
            Assert.assertEquals("next() should return elements in order",
                    names[count], element.getName());
            count++;
        }
    }

    /**
     * Verifies that concurrent access with the tree is disallowed.
     */
    @Test(expected = ConcurrentModificationException.class)
    public void concurrentModificationTest()
    {
        addTestableElements();

        for (BabyNames element : namesTree)
        {
            Assert.assertNotNull("Null element found in iterator", element);
            namesTree.clear(); //alter elements while iterating
        }
    }
}
